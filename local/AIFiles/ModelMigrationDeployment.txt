!wget https://labfiles-singapore.obs.ap-southeast-3.myhuaweicloud.com/2328/pcb_data.tar

!tar -xf pcb_data.tar

import os
import random
import cv2
import numpy as np
from  matplotlib import pyplot as plt
%matplotlib inline

classes = ["open", "short","mousebite","spur","copper",'pin-hole']  # 类别
file_path = "pcb_data/images/train2017"
file_list = os.listdir(file_path)
img_paths = random.sample(file_list, 4)
img_lists = []

for img_path in img_paths:
    img_path = os.path.join(file_path, img_path)
    img = cv2.imread(img_path)
    h, w, _ = img.shape
    tl = round(0.002 * (h + w) / 2) + 1
    color = [random.randint(0, 255) for _ in range(3)]
    if img_path.endswith('.png'):
        with open(img_path.replace("images", "labels").replace(".png", ".txt")) as f:
            labels = f.readlines()
    if img_path.endswith('.jpg'):
        with open(img_path.replace("images", "labels").replace(".jpg", ".txt")) as f:
            labels = f.readlines()
    for label in labels:
        l, x, y, wc, hc = [float(x) for x in label.strip().split()]
        x1 = int((x - wc / 2) * w)
        y1 = int((y - hc / 2) * h)
        x2 = int((x + wc / 2) * w)
        y2 = int((y + hc / 2) * h)

        cv2.rectangle(img, (x1, y1), (x2, y2),
                      color, thickness=tl, lineType=cv2.LINE_AA)
        cv2.putText(img,classes[int(l)],(x1,y1-2), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,111,222), 3, cv2.LINE_AA)
    img_lists.append(cv2.resize(img, (1280, 720)))

image = np.concatenate([np.concatenate(img_lists[:2], axis=1), np.concatenate(img_lists[2:], axis=1)], axis=0)
plt.rcParams["figure.figsize"] = (20, 10)
plt.imshow(image[:,:,::-1])
plt.axis('off')
plt.show()

!wget https://labfiles-singapore.obs.ap-southeast-3.myhuaweicloud.com/2328/code.tar

!tar -xf code.tar

!pip install ultralytics==8.0.109 numpy==1.20.0

!mkdir -p /home/ma-user/.config/Ultralytics
!cp code/Arial.ttf /home/ma-user/.config/Ultralytics/Arial.ttf
!rm -rf code/runs/detect

%cd /home/ma-user/work/code

import os
import yaml
dataset_path = os.getcwd().replace('/code','/pcb_data') #Note: You are advised to set this parameter to an absolute path to avoid dataset loading errors.
class_names_list = ['open','short','mousebite','spur','copper','pin-hole']

with open("pcb-detect.yaml", 'r', encoding='utf-8') as yaml_file:
    content = yaml.load(yaml_file, yaml.FullLoader)
    content['path'] = dataset_path
    content['train'] = 'images/train2017'
    content['val'] = 'images/val2017'
    content['nc'] = len(class_names_list)
    content['names'] = class_names_list
    content['download'] = None

with open("pcb-detect.yaml", 'w', encoding='utf-8') as f:
    yaml.dump(content, f)

%cd /home/ma-user/work/code
from ultralytics import YOLO

# Loading a Model
model = YOLO("yolov8n.pt")  # Load the pre-training model (recommended for training).

# Using Models
model.train(data="pcb-detect.yaml", epochs=10, imgsz=640)  # Training model
metrics = model.val()  # Evaluate model performance on a validation set

import os
import cv2
from matplotlib import pyplot as plt
%matplotlib inline

results = model("00041204.jpg" , save=True)  # Predicting images

save_dir = 'runs/detect/predict/00041204.jpg'
img = cv2.imread(save_dir)
img = img[:, :, ::-1]
plt.axis('off')
plt.imshow(img)
plt.show()

import os
import argparse
import sys
import yaml
import moxing as mox
import shutil

from ultralytics import YOLO


if __name__ == "__main__":
    app_url = os.path.dirname(__file__)
    sys.path.insert(0, os.path.dirname(__file__))
    parser = argparse.ArgumentParser(description="train yolov8")
    parser.add_argument("--data_url", type=str, required=True)#Input path of the training dataset, in yolo format.
    parser.add_argument("--train_url", type=str, required=True)#Output path of the training model
    parser.add_argument("--imgsz", type=int, default=640)#Training Picture Size
    parser.add_argument("--epochs", type=int, default=100)#Training rounds
    parser.add_argument("--batch", type=int, default=16)#Number of training batches
    parser.add_argument("--class_names", type=str, default='person,bicycle')#Category definition. The value is a character string. Multiple categories are separated by commas (,). Spaces are not allowed.
    args = parser.parse_args()

    class_names_list = args.class_names.split(',')
    current_path = os.getcwd()
    print("CurrentDir:", current_path)
    if not os.path.exists(os.path.join(current_path, "yolov8n.pt")):
        #The yolov8 source code checks whether yolov8n.pt exists in the running directory. If not, the yolov8n.pt will be downloaded from the Internet. However, the ModelArts training environment cannot be downloaded and copied to the running directory.
        shutil.copy(os.path.join(app_url, "yolov8n.pt"), os.path.join(current_path, "yolov8n.pt"))
        os.makedirs("/home/ma-user/.config/Ultralytics", exist_ok=True)
        shutil.copy(os.path.join(app_url, "Arial.ttf"), "/home/ma-user/.config/Ultralytics/Arial.ttf")
        print("Copy yolov8n.pt & Arial.ttf Successed.")

    #Update Dataset Configuration File
    with open(os.path.join(app_url, "train", "voc.yaml"), 'r', encoding='utf-8') as yaml_file:
        content = yaml.load(yaml_file, yaml.FullLoader)
        content['download'] = None
        content['train'] = 'images/train2017'
        content['val'] = 'images/val2017'
        content['nc'] = len(class_names_list)
        content['names'] = class_names_list
        content['path'] = args.data_url
    with open(os.path.join(app_url, "train", "voc_cache.yaml"), 'w', encoding='utf-8') as f:
        yaml.dump(content, f)

    #training
    model = YOLO("yolov8n.pt")
    model.train(data=os.path.join(app_url, "train", "voc_cache.yaml"), epochs=args.epochs, imgsz=args.imgsz,
                batch=args.batch, project=args.train_url)
    metrics = model.val()

    #Copying the training product
    mox.file.make_dirs(os.path.join(args.train_url, "model"))
    mox.file.copy(os.path.join(app_url, "train", "config.json"), os.path.join(args.train_url, "model", "config.json"))
    mox.file.copy(os.path.join(app_url, "train", "customize_service.py"),
                  os.path.join(args.train_url, "model", "customize_service.py"))
    mox.file.copy(os.path.join(args.train_url, "train", "weights", "best.pt"),
                  os.path.join(args.train_url, "model", "best.pt"))

%cd /home/ma-user/work
import os
dataset_path = "/home/ma-user/work/pcb_data"

!python /home/ma-user/work/code/train.py --data_url {dataset_path} --train_url 'test_train_outs' --imgsz 640 \
    --epochs 10 --batch 16 --class_names 'open,short,mousebite,spur,copper,pin-hole'

import moxing as mox
mox.file.copy_parallel('/home/ma-user/work/code','obs://ll-test/code')
mox.file.copy_parallel('/home/ma-user/work/pcb_data','obs://ll-test/pcb_data')

try:
    from model_service.pytorch_model_service import PTServingBaseService
except:
    PTServingBaseService = object

import os
from ultralytics import YOLO
import logging
import torch
import cv2
import numpy as np

class CustomizeService(PTServingBaseService):
    def __init__(self, model_name, model_path):
        self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
        if torch.cuda.is_available():
            logger.info('Using GPU for inference')
        else:
            logger.info('Using CPU for inference')
        print(f'running on {self.device}')
        self.code_url = os.path.dirname(os.path.abspath(__file__))
        self.model = YOLO(os.path.join(self.code_url, "best.pt"))
        self.model.to(torch.device(self.device))
        self.labels = self.model.module.name if hasattr(self.model, 'module') else self.model.names

def _preprocess(self, data):
    data_list = []
    for _, v in data.items():
        for _, file_content in v.items():
            file_content = file_content.read()
            img = cv2.imdecode(np.frombuffer(file_content, np.uint8), cv2.IMREAD_COLOR)
            data_list.append(img)
    return data_list

def _inference(self, data):
    with torch.no_grad():
        data = self.model(data[0])
    return data

def _postprocess(self, data):
    result_return = dict()
    data = data[0].to(torch.device('cpu'))
    boxes = data.boxes
    if data is not None:
        boxes = data.boxes
        picked_boxes = [[box[1], box[0], box[3], box[2]] for box in boxes.xyxy.tolist()]
        picked_classes = self.convert_labels(boxes.cls)
        picked_score = boxes.conf
        result_return['detection_classes'] = picked_classes
        result_return['detection_boxes'] = picked_boxes
        result_return['detection_scores'] = picked_score.tolist()
    else:
        result_return['detection_classes'] = []
        result_return['detection_boxes'] = []
        result_return['detection_scores'] = []
    return result_return

def convert_labels(self, label_list):
    if isinstance(label_list, np.ndarray):
        label_list = label_list.tolist()
    label_names = [self.labels[int(index)] for index in label_list]
    return label_names

%cd /home/ma-user/work/code/output/model
import os
from customize_service import CustomizeService

test_path = "/home/ma-user/work/code/00041204.jpg"
service = CustomizeService(model_name="yolov8", model_path="best.pt")

post_data = {"input_txt": {os.path.basename(test_path): open(test_path, "rb")}}

file_data = service._preprocess(post_data)
detect_data = service._inference(file_data)
result = service._postprocess(detect_data)
print('result:',result)

import moxing as mox
mox.file.copy_parallel("/home/ma-user/work/code/output/model","obs://ll-test/model")



